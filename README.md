</br></br>
# 1. 프로젝트 소개
- Picterest API를 이용하여 이미지를 CollectionView에 표시합니다.
- CollectionView의 FlowLayout을 커스텀하여 이미지의 사이즈에 맞춰서 셀이 그려집니다.
- 첫번째 화면의 별을 클릭하여 이미지와 이미지의 제목을 저장할 수 있습니다.
- 두번째 화면에서 이미지를 꾹 클릭해 해당 이미지를 삭제 할 수 있습니다.

# 2. 사용 기술
- CoreData
- FileManager
- CollectionView CustomFlowLayout
- MVVM
</br></br>
# 3. 팀원 소개

| 콩벌레 |
|:---:|
|![스크린샷 2022-07-05 오후 12 39 49](https://user-images.githubusercontent.com/66169740/177245382-ce7471c7-0401-4eb9-97de-1b59bef22d7f.png)|




</br></br>
# 4. 구현 화면

| 첫번째 화면 이미지 - pagination| 첫번째 화면 - 이미지 저장 | 두번째 화면 - 저장 이미지 화면 업데이트 | 두번째 화면 - 이미지 삭제 |
|:---:|:---:|:---:|:---:|
|![화면_기록_2022-07-29_오후_10_01_48_AdobeExpress](https://user-images.githubusercontent.com/58679737/181778000-473ca274-7ba8-45ef-ac1e-97d5d1b465d5.gif)|![화면_기록_2022-07-29_오후_10_01_48_AdobeExpress (1)](https://user-images.githubusercontent.com/58679737/181778116-029a538a-2237-48e9-bc10-eedfae856626.gif)|![화면_기록_2022-07-29_오후_10_01_48_AdobeExpress (4)](https://user-images.githubusercontent.com/58679737/181898055-5eae314f-354c-4fc0-bec6-bb4fbe5b87b8.gif)|![화면_기록_2022-07-29_오후_10_01_48_AdobeExpress (3)](https://user-images.githubusercontent.com/58679737/181778512-e2787186-fc9b-4f8e-bd4c-f5d6beba3ab8.gif) | 




</br></br>
# 5. 구현 기능
## 첫번째 화면 - 이미지 리스트 뷰
- 콜렉션뷰의 flowlayout 커스텀을 통해 이미지 셀의 높이를 동적으로 계산해서, 이미지의 높이에 따라 셀의 높이도 변경
- 별모양 버튼을 클릭하는 경우 이미지의 메모를 적고, 로컬파일에 이미지 저장, Coredata에 이미지 정보 저장
- 밑으로 스크롤시 추가 이미지 로딩

## 두번째 화면 - 이미지 저장 뷰 
- 저장된 이미지를 첫번째 화면과 동일하게 이미지의 높이에 따라 셀의 높이를 동적으로 계산하여 표시
- 이미지를 꾹 누를시 삭제
- 이미지 메모를 셀의 좌측 상단에 표시

</br></br>
# 6. 고민한/막힌 부분

## MVC로 할것인가 MVVM으로 할것인가
- 해당 프로젝트의 전제가 되는 두개의 뷰는 서로 기능이 거의 비슷함
- 첫번째 뷰는 API에서 데이터를 가지고 와서 콜렉션 뷰에 보여주는 기능이 주가 되고 두번째 뷰는 CoreData와 LocalFile로 저장된 데이터를 가지고 와서 콜렉션 뷰에 보여주는 기능이 주가 된다.
- 그 외에는 가지고 오는 저장소, 저장하냐 삭제하냐 기능을 제외하고는 거의 비슷함
- 따라서 코드의 재사용성을 염두해 두고 MVVM 패턴을 채택함

## NSCache로 할것인가 URLCache로 할것인가

- NSCache는 특정 키값을 이용해 캐시에 저장을 하는 방식이고 URLCache는 URLSession의 DataTask나 request를 저장하는 방식
- image를 가져올때마다 서버에 통신을 해야하므로 저장과 통신을 한번에 할 수 있는 URLCache로 하기로 결정

<br><br>

# 7. 회고
이번 멘토링을 통해서 기존에는 기능 개발을 위주로 코드를 작성 했지만, 유지보수가 원활한 코드를 작성하는게 얼마나 중요한지 깨달았다. 나는 여태까지 protocol을 delegate 패턴을 사용할때만 이용해 왔다. 하지만 OOP와 POP를 알고나서 protocol을 활용하는 방식을 알게되었다. 그래서 이번 프로젝트에서 유지보수가 원활한 코드를 작성하기 위해 OOP 또는 POP 그리고 클린 아키텍처를 적용하려고 했었다. 다만 아직 POP와 OOP의 정확한 차이점, 특징등등을 파악하지 못했고, 코드를 짤떄마다 이 코드가 solid 원칙을 지키고 있는게 맞는이, 아닌지 정확하게 판단 할 수 없었다. 그렇게 어떤식으로 설계해야 하는지 계속 고민하다가 시간이 많이 지나버려서 프로젝트에는 적용을 해보지 못했다. 그러나 어느정도 공부 하고나서 이 프로젝트를 리팩토링 해볼 생각이다.
